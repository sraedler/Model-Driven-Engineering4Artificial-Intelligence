@inproceedings{10.5555/2662593.2662595,
author = {Hastjarjanto, Tom and Jeuring, Johan and Leather, Sean},
title = {A DSL for Describing the Artificial Intelligence in Real-Time Video Games},
year = {2013},
isbn = {9781467362634},
publisher = {IEEE Press},
abstract = {Many games have computer-controlled agents that play against a player. The behavior of these computer-controlled agents is described by means of the artificial intelligence (AI) in the game. The AI is an important component of the game, and needs to be developed carefully, and adapted regularly. This paper introduces a novel language for describing the decision making process of the AI in real-time video games. We develop a declarative, domain-specific language (DSL) embedded in the functional programming language Haskell for real-time video games. We use the DSL to describe the AI of a prototype real-time video game.},
booktitle = {Proceedings of the 3rd International Workshop on Games and Software Engineering: Engineering Computer Games to Enable Positive, Progressive Change},
pages = {8–14},
numpages = {7},
location = {San Francisco, California},
series = {GAS '13}
}

@inproceedings{10.5555/2008503.2008556,
author = {Lortal, Ga\"{e}lle and Dhouib, Saadia and G\'{e}rard, S\'{e}bastien},
title = {Integrating Ontological Domain Knowledge into a Robotic DSL},
year = {2010},
isbn = {9783642212093},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Coming from the Artificial Intelligence (AI) and Semantic Web (SW) circles, ontologies are used mainly to represent domains. The Model Driven Engineering (MDE) field gave birth to Domain Specific Languages to represent a particular technical domain. Abstracting from their uses, we consider as many others researchers that ontologies and models are closer than their original fields could get to think. Furthermore, their building or development are facing the same problems. They are costly and need experts' interviews in order to grasp specific knowledge and structure it. Likewise, ontologies and DSL can benefit from each other domains in reusing construction methodologies and even reusing knowledge modelled in another format. In this paper we first present the ontologies and DSL definition we use and some methodologies of development enabling the reuse of knowledge (as alignment, fusion). We then present how we propose to reuse the knowledge of a robotic ontology to develop robotic DSLs within the PROTEUS project in order to inject readymade domain information to the DSL.},
booktitle = {Proceedings of the 2010 International Conference on Models in Software Engineering},
pages = {401–414},
numpages = {14},
location = {Oslo, Norway},
series = {MODELS'10}
}

@inproceedings{10.1145/3339252.3339278,
author = {Stelly, Christopher and Roussev, Vassil},
title = {Language-Based Integration of Digital Forensics &amp; Incident Response},
year = {2019},
isbn = {9781450371643},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3339252.3339278},
doi = {10.1145/3339252.3339278},
abstract = {In the cybersecurity domain, the level of standardization and interoperability among cybersecurity products from different vendors, including open-source ones, is fairly low. Although understandable from a business perspective, this deficiency makes it difficult and expensive for analysts to put together custom solutions and to have visibility across their entire IT infrastructure. It also hampers the adoption of custom data analytics and AI solutions, and slows down the exchange of threat detection and mitigation solutions.Recently, the Nugget domain specific language (DSL) has been proposed as a solution to the integration of digital forensics computations. The essential idea is to use a data flow language, somewhat similar to SQL, and an extensible run-time environment to decouple the specification of forensic computations from their implementation.In this paper, we study the integration of Nugget with security monitoring tools; specifically, we integrate Google's GRR incident response framework, and the de facto standard for log aggregation: Splunk. We demonstrate the utility of this type standardization to both tool developers and end-user analysts/IT administrators. We discuss potential implications of having such a DSL becoming widely adopted across the entire domain of cybersecurity.},
booktitle = {Proceedings of the 14th International Conference on Availability, Reliability and Security},
articleno = {27},
numpages = {6},
keywords = {digital forensics, nugget, domain specific language, incident response, grr},
location = {Canterbury, CA, United Kingdom},
series = {ARES '19}
}

@inproceedings{10.1145/1133981.1134003,
author = {Johnson, Troy A. and Eigenmann, Rudolf},
title = {Context-Sensitive Domain-Independent Algorithm Composition and Selection},
year = {2006},
isbn = {1595933204},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1133981.1134003},
doi = {10.1145/1133981.1134003},
abstract = {Progressing beyond the productivity of present-day languages appears to require using domain-specific knowledge. Domain-specific languages and libraries (DSLs) proliferate, but most optimizations and language features have limited portability because each language's semantics are related closely to its domain. We explain how any DSL compiler can use a domain-independent AI planner to implement algorithm composition as a language feature. Our notion of composition addresses a common DSL problem: good library designers tend to minimize redundancy by including only fundamental procedures that users must chain together into call sequences. Novice users are confounded by not knowing an appropriate sequence to achieve their goal. Composition allows the programmer to define and call an abstract algorithm (AA) like a procedure. The compiler replaces an AA call with a sequence of library calls, while considering the calling context. Because AI planners compute a sequence of operations to reach a goal state, the compiler can implement composition by analyzing the calling context to provide the planner's initial state. Nevertheless, mapping composition onto planning is not straightforward because applying planning to software requires extensions to classical planning, and procedure specifications may be incomplete when expressed in a planning language. Compositions may not be provably correct, so our approach mitigates semantic incompleteness with unobtrusive programmer-compiler interaction. This tradeoff is key to making composition a practical and natural feature of otherwise imperative languages, whose users eschew complex logical specifications. Compositions satisfying an AA may not be equal in performance, memory usage, or precision and require selection of a preferred solution. We examine language design and implementation issues, and we perform a case study on the BioPerl bioinformatics library.},
booktitle = {Proceedings of the 27th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {181–192},
numpages = {12},
keywords = {algorithm composition, algorithm selection, automated planning, bioinformatics, domain-specific languages},
location = {Ottawa, Ontario, Canada},
series = {PLDI '06}
}

@article{10.1145/1133255.1134003,
author = {Johnson, Troy A. and Eigenmann, Rudolf},
title = {Context-Sensitive Domain-Independent Algorithm Composition and Selection},
year = {2006},
issue_date = {June 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {41},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1133255.1134003},
doi = {10.1145/1133255.1134003},
abstract = {Progressing beyond the productivity of present-day languages appears to require using domain-specific knowledge. Domain-specific languages and libraries (DSLs) proliferate, but most optimizations and language features have limited portability because each language's semantics are related closely to its domain. We explain how any DSL compiler can use a domain-independent AI planner to implement algorithm composition as a language feature. Our notion of composition addresses a common DSL problem: good library designers tend to minimize redundancy by including only fundamental procedures that users must chain together into call sequences. Novice users are confounded by not knowing an appropriate sequence to achieve their goal. Composition allows the programmer to define and call an abstract algorithm (AA) like a procedure. The compiler replaces an AA call with a sequence of library calls, while considering the calling context. Because AI planners compute a sequence of operations to reach a goal state, the compiler can implement composition by analyzing the calling context to provide the planner's initial state. Nevertheless, mapping composition onto planning is not straightforward because applying planning to software requires extensions to classical planning, and procedure specifications may be incomplete when expressed in a planning language. Compositions may not be provably correct, so our approach mitigates semantic incompleteness with unobtrusive programmer-compiler interaction. This tradeoff is key to making composition a practical and natural feature of otherwise imperative languages, whose users eschew complex logical specifications. Compositions satisfying an AA may not be equal in performance, memory usage, or precision and require selection of a preferred solution. We examine language design and implementation issues, and we perform a case study on the BioPerl bioinformatics library.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {181–192},
numpages = {12},
keywords = {algorithm selection, domain-specific languages, automated planning, algorithm composition, bioinformatics}
}

